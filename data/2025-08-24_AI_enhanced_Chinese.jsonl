{"id": "2508.15070", "categories": ["cs.DB"], "pdf": "https://arxiv.org/pdf/2508.15070", "abs": "https://arxiv.org/abs/2508.15070", "authors": ["Daichi Amagata"], "title": "Random Sampling over Spatial Range Joins", "comment": "Accepted version of our ICDE2025 paper", "summary": "Spatial range joins have many applications, including geographic information\nsystems, location-based social networking services, neuroscience, and\nvisualization. However, joins incur not only expensive computational costs but\nalso too large result sets. A practical and reasonable approach to alleviating\nthese issues is to return random samples of the join results. Although this is\npromising and sufficient for many applications involving spatial range joins,\nefficiently computing random samples is not trivial. This is because we must\nobtain random join samples without running spatial range joins. We address this\nchallenging problem for the first time and aim at designing a time- and\nspace-efficient algorithm. First, we design two baseline algorithms that employ\nexisting techniques for random sampling and show that they are not efficient.\nThen, we propose a new data structure that can deal with our problem in\n$\\tilde{O}(n + m + t)$ expected time and $O(n+m)$ space, where $n$ and $m$ are\nthe sizes of two point sets and $t$ is the required number of samples. We\nconduct extensive experiments using four real spatial datasets, and the results\ndemonstrate that our algorithm is significantly faster than the baselines in\nmost tests.", "AI": {"tldr": "\u8be5\u6587\u9996\u6b21\u7814\u7a76\u5728\u4e0d\u6267\u884c\u5b8c\u6574\u8fde\u63a5\u7684\u524d\u63d0\u4e0b\u5bf9\u7a7a\u95f4\u8303\u56f4\u8fde\u63a5\u8fdb\u884c\u968f\u673a\u91c7\u6837\uff0c\u63d0\u51fa\u65b0\u6570\u636e\u7ed3\u6784\u5b9e\u73b0\u8fd1\u7ebf\u6027\u590d\u6742\u5ea6\u5e76\u5728\u5b9e\u9a8c\u4e2d\u8868\u73b0\u4f18\u8d8a\u3002", "motivation": "\u7a7a\u95f4\u8303\u56f4\u8fde\u63a5\u5e94\u7528\u5e7f\u6cdb\u4f46\u4ea7\u751f\u7684\u7ed3\u679c\u96c6\u5de8\u5927\u4e14\u8ba1\u7b97\u4ee3\u4ef7\u9ad8\uff0c\u8fd4\u56de\u968f\u673a\u6837\u672c\u53ef\u7f13\u89e3\u95ee\u9898\uff0c\u4f46\u8981\u5728\u4e0d\u5b9e\u9645\u8fd0\u884c\u8303\u56f4\u8fde\u63a5\u7684\u60c5\u51b5\u4e0b\u5f97\u5230\u968f\u673a\u6837\u672c\u662f\u5177\u6709\u6311\u6218\u6027\u7684\u3002", "method": "\u5148\u8bbe\u8ba1\u4e24\u4e2a\u4f7f\u7528\u73b0\u6709\u968f\u673a\u91c7\u6837\u6280\u672f\u7684\u57fa\u7ebf\u7b97\u6cd5\u5e76\u8bc1\u660e\u5176\u4f4e\u6548\uff0c\u7136\u540e\u63d0\u51fa\u4e00\u79cd\u65b0\u7684\u6570\u636e\u7ed3\u6784\uff0c\u80fd\u591f\u5728\\tilde{O}(n+m+t) \u671f\u671b\u65f6\u95f4\u548c O(n+m) \u7a7a\u95f4\u5185\u751f\u6210 t \u4e2a\u6837\u672c\u3002", "result": "\u6784\u5efa\u7684\u6570\u636e\u7ed3\u6784\u5728\u7406\u8bba\u4e0a\u8fbe\u5230\u4e86\u8fd1\u7ebf\u6027\u65f6\u95f4\u548c\u7ebf\u6027\u7a7a\u95f4\u590d\u6742\u5ea6\uff0c\u5b9e\u9a8c\uff08\u56db\u4e2a\u771f\u5b9e\u6570\u636e\u96c6\uff09\u663e\u793a\u5728\u5927\u591a\u6570\u6d4b\u8bd5\u573a\u666f\u4e0b\u663e\u8457\u5feb\u4e8e\u57fa\u7ebf\u3002", "conclusion": "\u8bba\u6587\u63d0\u51fa\u4e86\u9996\u4e2a\u9488\u5bf9\u7a7a\u95f4\u8303\u56f4\u8fde\u63a5\u968f\u673a\u91c7\u6837\u7684\u95ee\u9898\u7684\u9ad8\u6548\u7b97\u6cd5\uff0c\u8bc1\u660e\u5728\u65f6\u95f4\u548c\u7a7a\u95f4\u4e0a\u5747\u6709\u4f18\u52bf\uff0c\u4e14\u5b9e\u9a8c\u9a8c\u8bc1\u4f18\u4e8e\u57fa\u7ebf\u7b97\u6cd5\u3002"}}
{"id": "2508.15238", "categories": ["cs.DB"], "pdf": "https://arxiv.org/pdf/2508.15238", "abs": "https://arxiv.org/abs/2508.15238", "authors": ["Yinyu Liu", "Kaiqiang Yu", "Shengxin Liu", "Cheng Long", "Zhaoquan Gu"], "title": "Temporal $k$-Core Query, Revisited", "comment": null, "summary": "Querying cohesive subgraphs in temporal graphs is essential for understanding\nthe dynamic structure of real-world networks, such as evolving communities in\nsocial platforms, shifting hyperlink structures on the Web, and transient\ncommunication patterns in call networks. Recently, research has focused on the\ntemporal $k$-core query, which aims to identify all $k$-cores across all\npossible time sub-intervals within a given query interval. The state-of-the-art\nalgorithm OTCD mitigates redundant computations over overlapping sub-intervals\nby exploiting inclusion relationships among $k$-cores in different time\nintervals. Nevertheless, OTCD remains limited in scalability due to the\ncombinatorial growth in interval enumeration and repeated processing. In this\npaper, we revisit the temporal $k$-core query problem and introduce a novel\nalgorithm CoreT, which dynamically records the earliest timestamp at which each\nvertex or edge enters a $k$-core. This strategy enables substantial pruning of\nredundant computations. As a result, CoreT requires only a single pass over the\nquery interval and achieves improved time complexity, which is linear in both\nthe number of temporal edges within the query interval and the duration of the\ninterval, making it highly scalable for long-term temporal analysis.\nExperimental results on large real-world datasets show that CoreT achieves up\nto four orders of magnitude speedup compared to the existing state-of-the-art\nOTCD, demonstrating its effectiveness and scalability for temporal $k$-core\nanalysis.", "AI": {"tldr": "CoreT\u901a\u8fc7\u8bb0\u5f55\u5143\u7d20\u8fdb\u5165k-core\u7684\u6700\u65e9\u65f6\u95f4\u5e76\u5355\u6b21\u7ebf\u6027\u626b\u63cf\u533a\u95f4\uff0c\u663e\u8457\u526a\u679d\u5197\u4f59\uff0c\u5b9e\u9a8c\u8bc1\u660e\u6bd4OTCD\u5feb\u6700\u591a10000\u500d\uff0c\u9002\u5408\u957f\u65f6\u6bb5\u7684\u65f6\u5e8fk-core\u67e5\u8be2\u3002", "motivation": "\u73b0\u6709OTCD\u7b97\u6cd5\u867d\u5229\u7528\u5305\u542b\u5173\u7cfb\u51cf\u5c11\u91cd\u590d\uff0c\u4f46\u5728\u533a\u95f4\u679a\u4e3e\u4e0a\u4ecd\u5448\u7ec4\u5408\u7206\u70b8\uff0c\u96be\u4ee5\u6269\u5c55\u5230\u957f\u65f6\u6bb5\u5206\u6790\u3002", "method": "CoreT\u52a8\u6001\u7ef4\u62a4\u6bcf\u4e2a\u9876\u70b9/\u8fb9\u8fdb\u5165k-core\u7684\u6700\u65e9\u65f6\u95f4\uff0c\u5e76\u57fa\u4e8e\u6b64\u4fe1\u606f\u5728\u67e5\u8be2\u533a\u95f4\u5185\u5355\u6b21\u4ece\u5de6\u5230\u53f3\u626b\u63cf\u65f6\u95f4\u6233\uff0c\u907f\u514d\u5bf9\u91cd\u53e0\u5b50\u533a\u95f4\u7684\u91cd\u590d\u5904\u7406\u3002", "result": "\u5728\u5927\u89c4\u6a21\u771f\u5b9e\u6570\u636e\u96c6\u4e0a\uff0cCoreT\u76f8\u8f83\u4e8eOTCD\u6700\u9ad8\u53ef\u8fbe\u56db\u4e2a\u6570\u91cf\u7ea7\u7684\u52a0\u901f\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(#\u65f6\u95f4\u8fb9 \u00d7 \u533a\u95f4\u957f\u5ea6)\uff0c\u5bf9\u957f\u65f6\u5e8f\u5206\u6790\u8868\u73b0\u51fa\u9ad8\u53ef\u6269\u5c55\u6027\u3002", "conclusion": "\u63d0\u51faCoreT\u7b97\u6cd5\uff0c\u901a\u8fc7\u8bb0\u5f55\u9876\u70b9/\u8fb9\u8fdb\u5165k-core\u7684\u6700\u65e9\u65f6\u95f4\u6233\uff0c\u5b9e\u73b0\u5355\u6b21\u7ebf\u6027\u626b\u63cf\u67e5\u8be2\u533a\u95f4\uff0c\u80fd\u6709\u6548\u526a\u679d\u5197\u4f59\u8ba1\u7b97\u3002"}}
{"id": "2508.15276", "categories": ["cs.DB", "cs.CL"], "pdf": "https://arxiv.org/pdf/2508.15276", "abs": "https://arxiv.org/abs/2508.15276", "authors": ["Zhongjun Ding", "Yin Lin", "Tianjing Zeng"], "title": "AmbiSQL: Interactive Ambiguity Detection and Resolution for Text-to-SQL", "comment": null, "summary": "Text-to-SQL systems translate natural language questions into SQL queries,\nproviding substantial value for non-expert users. While large language models\n(LLMs) show promising results for this task, they remain error-prone. Query\nambiguity has been recognized as a major obstacle for LLM-based Text-to-SQL\nsystems, leading to misinterpretation of user intent and inaccurate SQL\ngeneration. We demonstrate AmbiSQL, an interactive system that automatically\ndetects query ambiguities and guides users through intuitive multiple-choice\nquestions to clarify their intent. Our approach introduces a fine-grained\nambiguity taxonomy for identifying ambiguities that affect database element\nmapping and LLM reasoning, then incorporates user feedback to rewrite ambiguous\nquestions. Evaluation on an ambiguous query dataset shows that AmbiSQL achieves\n87.2% precision in ambiguity detection and improves SQL exact match accuracy by\n50% when integrated with Text-to-SQL systems. Our demonstration showcases the\nsignificant performance gains and highlights the system's practical usability.\nCode repo and demonstration are available at:\nhttps://github.com/JustinzjDing/AmbiSQL.", "AI": {"tldr": "AmbiSQL\u81ea\u52a8\u8bc6\u522b\u5e76\u901a\u8fc7\u591a\u9879\u9009\u62e9\u4ea4\u4e92\u6f84\u6e05\u7528\u6237\u67e5\u8be2\u6b67\u4e49\uff0c\u663e\u8457\u63d0\u9ad8Text-to-SQL\u7cfb\u7edf\u7684\u51c6\u786e\u7387\u548c\u5b9e\u7528\u6027\u3002", "motivation": "\u73b0\u6709LLM\u5728Text-to-SQL\u4efb\u52a1\u4e2d\u6613\u53d7\u67e5\u8be2\u6b67\u4e49\u5f71\u54cd\uff0c\u5bfc\u81f4\u8bef\u89e3\u7528\u6237\u610f\u56fe\u548c\u751f\u6210\u9519\u8befSQL\uff1b\u56e0\u6b64\u9700\u8981\u4e00\u79cd\u81ea\u52a8\u5316\u4ea4\u4e92\u65b9\u5f0f\u68c0\u6d4b\u5e76\u6d88\u9664\u6b67\u4e49\uff0c\u4ee5\u63d0\u5347\u7cfb\u7edf\u53ef\u9760\u6027\u548c\u53ef\u7528\u6027\u3002", "method": "\u6784\u5efa\u7ec6\u7c92\u5ea6\u6b67\u4e49\u5206\u7c7b\u6cd5\uff08\u9488\u5bf9\u6570\u636e\u5e93\u5143\u7d20\u6620\u5c04\u548cLLM\u63a8\u7406\u7684\u6b67\u4e49\uff09\uff0c\u4f7f\u7528\u5206\u7c7b\u5668\u68c0\u6d4b\u6b67\u4e49\u5e76\u751f\u6210\u591a\u9879\u9009\u62e9\u6f84\u6e05\u95ee\u9898\uff0c\u57fa\u4e8e\u7528\u6237\u53cd\u9988\u5bf9\u539f\u59cb\u81ea\u7136\u8bed\u8a00\u67e5\u8be2\u8fdb\u884c\u6539\u5199\uff0c\u968f\u540e\u5c06\u6539\u5199\u7ed3\u679c\u8f93\u5165\u73b0\u6709Text-to-SQL\u6a21\u578b\u751f\u6210SQL\u3002", "result": "\u5728\u4e00\u4e2a\u6b67\u4e49\u67e5\u8be2\u6570\u636e\u96c6\u4e0a\u7684\u8bc4\u4f30\u8868\u660e\uff1a\u6b67\u4e49\u68c0\u6d4b\u7cbe\u786e\u7387\u8fbe87.2%\uff0c\u4e0eText-to-SQL\u7cfb\u7edf\u96c6\u6210\u540e\uff0cSQL\u7cbe\u51c6\u5339\u914d\uff08exact match\uff09\u63d0\u5347\u4e8650%\u3002", "conclusion": "\u8be5\u8bba\u6587\u63d0\u51fa\u4e86AmbiSQL\uff0c\u4e00\u79cd\u4ea4\u4e92\u5f0fText-to-SQL\u7cfb\u7edf\uff0c\u901a\u8fc7\u81ea\u52a8\u68c0\u6d4b\u67e5\u8be2\u6b67\u4e49\u5e76\u7528\u591a\u9879\u9009\u62e9\u95ee\u9898\u5f15\u5bfc\u7528\u6237\u6f84\u6e05\u610f\u56fe\uff0c\u4ece\u800c\u63d0\u9ad8SQL\u751f\u6210\u51c6\u786e\u7387\u3002"}}
{"id": "2508.15285", "categories": ["cs.DB", "C.2.4; H.2.4; D.2.11"], "pdf": "https://arxiv.org/pdf/2508.15285", "abs": "https://arxiv.org/abs/2508.15285", "authors": ["Chunyu Zhao", "Hongzhi Wang", "Kaixin Zhang", "Hongliang Li", "Yihan Zhang", "Jiawei Zhang", "Kunkai Gu", "Yuan Tian", "Xiangdong Huang", "Jingyi Xu"], "title": "Efficient Cloud-Edge-Device Query Execution Based on Collaborative Scan Operator", "comment": "12 pages, 23 figures. Submitted to IEEE Transactions on ICDE", "summary": "In cloud-edge-device (CED) collaborative query (CQ) processing, by leveraging\nCED collaboration, the advantages of both cloud computing and edge resources\ncan be fully integrated. However, it is difficult to implement collaborative\noperators that can flexibly switch between the cloud and the edge during query\nexecution. Thus, in this paper, we aim to improve the query performance when\nthe edge resources reach a bottleneck. To achieve seamless switching of query\nexecution between the cloud and edge, we propose a CQ processing method by\nestablishing a CED collaborative framework based on the collaborative scan\noperator, so that query execution can be transferred to the cloud at any time\nwhen the edge resources are saturated. Extensive experiments show that, under\nsufficient network download bandwidth, the CED collaborative scan operator can\neffectively alleviate the performance degradation of scan operators caused by\nhigh I/O load and CPU wait time at the edge. It also achieves balanced resource\nscheduling between the cloud and edge.", "AI": {"tldr": "\u63d0\u51fa\u4e00\u79cd\u57fa\u4e8e\u534f\u540c\u626b\u63cf\u7b97\u5b50\u7684 CED \u534f\u4f5c\u6846\u67b6\uff0c\u652f\u6301\u8fb9\u7f18\u8d44\u6e90\u9971\u548c\u65f6\u5c06\u67e5\u8be2\u6267\u884c\u65e0\u7f1d\u8fc1\u79fb\u5230\u4e91\u7aef\uff0c\u5b9e\u9a8c\u5728\u9ad8\u5e26\u5bbd\u4e0b\u9a8c\u8bc1\u4e86\u5176\u6027\u80fd\u548c\u8d44\u6e90\u5747\u8861\u6548\u679c\u3002", "motivation": "\u5728\u4e91-\u8fb9-\u7aef\u534f\u540c\u67e5\u8be2\u5904\u7406\u4e2d\uff0c\u8fb9\u7f18\u8d44\u6e90\uff08I/O \u548c CPU\uff09\u8fbe\u5230\u74f6\u9888\u65f6\uff0c\u96be\u4ee5\u7075\u6d3b\u5730\u5728\u4e91\u548c\u8fb9\u4e4b\u95f4\u5207\u6362\u6267\u884c\u4ee5\u7ef4\u6301\u67e5\u8be2\u6027\u80fd\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u79cd\u53ef\u4ee5\u65e0\u7f1d\u5207\u6362\u6267\u884c\u4f4d\u7f6e\u7684\u534f\u4f5c\u7b97\u5b50\u3002", "method": "\u63d0\u51fa\u4e86\u57fa\u4e8e\u534f\u540c\u626b\u63cf\u7b97\u5b50\u7684 CED \u534f\u4f5c\u6846\u67b6\uff0c\u652f\u6301\u5728\u67e5\u8be2\u6267\u884c\u8fc7\u7a0b\u4e2d\u52a8\u6001\u5c06\u626b\u63cf\u64cd\u4f5c\u4ece\u8fb9\u7f18\u8fc1\u79fb\u5230\u4e91\u7aef\uff0c\u5229\u7528\u4e91\u7aef\u8ba1\u7b97\u4e0e\u8fb9\u7f18\u8d44\u6e90\u7ed3\u5408\uff0c\u901a\u8fc7\u7f51\u7edc\u4e0b\u8f7d\u5c06\u6570\u636e\u8f6c\u79fb\u5230\u4e91\u7aef\u7ee7\u7eed\u6267\u884c\u3002", "result": "\u5b9e\u9a8c\u8868\u660e\uff0c\u5728\u5145\u8db3\u7f51\u7edc\u4e0b\u8f7d\u5e26\u5bbd\u6761\u4ef6\u4e0b\uff0c\u534f\u540c\u626b\u63cf\u7b97\u5b50\u80fd\u6709\u6548\u51cf\u8f7b\u56e0\u8fb9\u7f18\u9ad8 I/O \u8d1f\u8f7d\u548c CPU \u7b49\u5f85\u5bfc\u81f4\u7684\u626b\u63cf\u6027\u80fd\u4e0b\u964d\uff0c\u5e76\u5b9e\u73b0\u4e91\u8fb9\u4e4b\u95f4\u7684\u8d44\u6e90\u5747\u8861\u8c03\u5ea6\u3002", "conclusion": "\u57fa\u4e8e\u534f\u540c\u626b\u63cf\u7b97\u5b50\u7684 CED \u534f\u4f5c\u6846\u67b6\u80fd\u591f\u5728\u8fb9\u7f18\u8d44\u6e90\u9971\u548c\u65f6\u65e0\u7f1d\u5c06\u67e5\u8be2\u6267\u884c\u5207\u6362\u5230\u4e91\u7aef\uff0c\u4ece\u800c\u7f13\u89e3\u8fb9\u7f18\u626b\u63cf\u7b97\u5b50\u6027\u80fd\u4e0b\u964d\u5e76\u5b9e\u73b0\u4e91\u8fb9\u8d44\u6e90\u8d1f\u8f7d\u5747\u8861\u3002"}}
{"id": "2508.15290", "categories": ["cs.DB"], "pdf": "https://arxiv.org/pdf/2508.15290", "abs": "https://arxiv.org/abs/2508.15290", "authors": ["Peiqi Yin", "Xiao Yan", "Qihui Zhou", "Hui Li", "Xiaolu Li", "Lin Zhang", "Meiling Wang", "Xin Yao", "James Cheng"], "title": "Gorgeous: Revisiting the Data Layout for Disk-Resident High-Dimensional Vector Search", "comment": "12 pages, 19 figures", "summary": "Similarity-based vector search underpins many important applications, but a\nkey challenge is processing massive vector datasets (e.g., in TBs). To reduce\ncosts, some systems utilize SSDs as the primary data storage. They employ a\nproximity graph, which connects similar vectors to form a graph and is the\nstate-of-the-art index for vector search. However, these systems are hindered\nby sub-optimal data layouts that fail to effectively utilize valuable memory\nspace to reduce disk access and suffer from poor locality for accessing\ndisk-resident data. Through extensive profiling and analysis, we found that the\nstructure of the proximity graph index is accessed more frequently than the\nvectors themselves, yet existing systems do not distinguish between the two. To\naddress this problem, we design the Gorgeous system with the principle of\nprioritizing graph structure over vectors. Specifically, Gorgeous features a\nmemory cache that keeps the adjacency lists of graph nodes to improve cache\nhits and a disk block format that explicitly stores neighbors' adjacency lists\nalong with a vector to enhance data locality. Experimental results show that\nGorgeous consistently outperforms two state-of-the-art disk-based systems for\nvector search, boosting average query throughput by over 60% and reducing query\nlatency by over 35%.", "AI": {"tldr": "\u901a\u8fc7\u4f18\u5148\u7f13\u5b58\u548c\u5e03\u5c40\u8fd1\u90bb\u56fe\u7ed3\u6784\uff0cGorgeous\u663e\u8457\u51cf\u5c11\u78c1\u76d8\u8bbf\u95ee\u5e76\u63d0\u5347\u78c1\u76d8\u578b\u5411\u91cf\u68c0\u7d22\u6027\u80fd\u3002", "motivation": "\u5728\u5927\u89c4\u6a21\u5411\u91cf\u68c0\u7d22\u4e2d\uff0c\u8fd1\u4f3c\u6700\u8fd1\u90bb\u5e38\u7528\u7684\u8fd1\u90bb\u56fe\u7d22\u5f15\u7ed3\u6784\u6bd4\u5411\u91cf\u672c\u8eab\u88ab\u66f4\u9891\u7e41\u8bbf\u95ee\uff0c\u4f46\u73b0\u6709\u7cfb\u7edf\u672a\u5bf9\u56fe\u7ed3\u6784\u4e0e\u5411\u91cf\u505a\u5dee\u5f02\u5316\u5904\u7406\uff0c\u5bfc\u81f4\u78c1\u76d8\u8bbf\u95ee\u548c\u5c40\u90e8\u6027\u4f4e\u6548\u3002", "method": "\u8bbe\u8ba1\u4e86\u4e00\u4e2a\u5185\u5b58\u7f13\u5b58\u7528\u4e8e\u5b58\u50a8\u56fe\u8282\u70b9\u7684\u90bb\u63a5\u5217\u8868\uff0c\u4ee5\u53ca\u4e00\u79cd\u78c1\u76d8\u5757\u683c\u5f0f\uff0c\u5c06\u5411\u91cf\u53ca\u5176\u90bb\u5c45\u7684\u90bb\u63a5\u5217\u8868\u4e00\u8d77\u5b58\u50a8\u4ee5\u63d0\u5347\u6570\u636e\u5c40\u90e8\u6027\uff1b\u5e76\u5728\u73b0\u6709\u4e24\u79cd\u57fa\u4e8e\u78c1\u76d8\u7684\u7cfb\u7edf\u4e0a\u8fdb\u884c\u5b9e\u9a8c\u8bc4\u4f30\u3002", "result": "\u5728\u5b9e\u9a8c\u4e2d\uff0cGorgeous\u76f8\u6bd4\u4e24\u79cd\u6700\u5148\u8fdb\u7684\u57fa\u4e8e\u78c1\u76d8\u7684\u5411\u91cf\u68c0\u7d22\u7cfb\u7edf\uff0c\u5e73\u5747\u67e5\u8be2\u541e\u5410\u91cf\u63d0\u5347\u8d85\u8fc760%\uff0c\u67e5\u8be2\u5ef6\u8fdf\u964d\u4f4e\u8d85\u8fc735%\u3002", "conclusion": "Gorgeous\u901a\u8fc7\u5c06\u90bb\u63a5\u8868\u7f13\u5b58\u653e\u5165\u5185\u5b58\u5e76\u5728\u78c1\u76d8\u5757\u4e2d\u4e0e\u5411\u91cf\u4e00\u8d77\u5b58\u50a8\u90bb\u5c45\u7684\u90bb\u63a5\u8868\uff0c\u4f18\u5148\u8003\u8651\u56fe\u7ed3\u6784\u800c\u975e\u5411\u91cf\uff0c\u5b9e\u73b0\u4e86\u66f4\u9ad8\u7684\u67e5\u8be2\u541e\u5410\u91cf\u548c\u66f4\u4f4e\u7684\u5ef6\u8fdf\u3002"}}
{"id": "2508.15694", "categories": ["cs.DB"], "pdf": "https://arxiv.org/pdf/2508.15694", "abs": "https://arxiv.org/abs/2508.15694", "authors": ["Yijie Zhou", "Shengyuan Lin", "Shufeng Gong", "Song Yu", "Shuhao Fan", "Yanfeng Zhang", "Ge Yu"], "title": "GoVector: An I/O-Efficient Caching Strategy for High-Dimensional Vector Nearest Neighbor Search", "comment": "12 pages, 12 figures, this paper is the English version of our\n  Chinese paper accepted for publication in Journal of Software, Vol. 37, No.\n  3, 2026", "summary": "Graph-based high-dimensional vector indices have become a mainstream solution\nfor large-scale approximate nearest neighbor search (ANNS). However, their\nsubstantial memory footprint often requires storage on secondary devices, where\nfrequent on-demand loading of graph and vector data leads to I/O becoming the\ndominant bottleneck, accounting for over 90\\% of query latency. Existing static\ncaching strategies mitigate this issue only in the initial navigation phase by\npreloading entry points and multi-hop neighbors, but they fail in the second\nphase where query-dependent nodes must be dynamically accessed to achieve high\nrecall. We propose GoVector, an I/O-efficient caching strategy tailored for\ndisk-based graph indices. GoVector combines (1) a static cache that stores\nentry points and frequently accessed neighbors, and (2) a dynamic cache that\nadaptively captures nodes with high spatial locality during the second search\nphase. To further align storage layout with similarity-driven search patterns,\nGoVector reorders nodes on disk so that similar vectors are colocated on the\nsame or adjacent pages, thereby improving locality and reducing I/O overhead.\nExtensive experiments on multiple public datasets show that GoVector achieves\nsubstantial performance improvements. At 90% recall, it reduces I/O operations\nby 46% on average, increases query throughput by 1.73x, and lowers query\nlatency by 42% compared to state-of-the-art disk-based graph indexing systems.", "AI": {"tldr": "GoVector\u901a\u8fc7\u9759\u6001+\u52a8\u6001\u7f13\u5b58\u53ca\u78c1\u76d8\u91cd\u6392\uff0c\u663e\u8457\u964d\u4f4e\u78c1\u76d8\u56fe\u7d22\u5f15\u7684I/O\uff0c\u63d0\u5347ANNS\u67e5\u8be2\u6548\u7387\u3002", "motivation": "\u5728\u5927\u89c4\u6a21\u57fa\u4e8e\u56fe\u7684ANNS\u4e2d\uff0c\u5185\u5b58\u4e0d\u8db3\u5bfc\u81f4\u7d22\u5f15\u9700\u653e\u5728\u6b21\u7ea7\u8bbe\u5907\uff0c\u9891\u7e41\u6309\u9700\u52a0\u8f7d\u56fe\u4e0e\u5411\u91cf\u4f7fI/O\u6210\u4e3a\u67e5\u8be2\u4e3b\u74f6\u9888\uff0c\u73b0\u6709\u9759\u6001\u7f13\u5b58\u65e0\u6cd5\u5e94\u5bf9\u67e5\u8be2\u4f9d\u8d56\u7684\u52a8\u6001\u8282\u70b9\u8bbf\u95ee\u3002", "method": "\u63d0\u51fa\u6df7\u5408\u7f13\u5b58\u7b56\u7565\uff1a\u9759\u6001\u7f13\u5b58\u4fdd\u5b58\u5165\u53e3\u70b9\u548c\u9891\u7e41\u8bbf\u95ee\u90bb\u5c45\uff1b\u52a8\u6001\u7f13\u5b58\u81ea\u9002\u5e94\u6355\u83b7\u7b2c\u4e8c\u9636\u6bb5\u9ad8\u7a7a\u95f4\u5c40\u90e8\u6027\u7684\u8282\u70b9\uff1b\u5e76\u91cd\u6392\u78c1\u76d8\u5b58\u50a8\uff0c\u4f7f\u76f8\u4f3c\u5411\u91cf\u5171\u7f6e\u4e8e\u76f8\u90bb\u9875\uff0c\u4ece\u800c\u63d0\u5347\u78c1\u76d8\u8bfb\u7684\u5c40\u90e8\u6027\u3002", "result": "\u5728\u591a\u4e2a\u516c\u5f00\u6570\u636e\u96c6\u4e0a\u5b9e\u9a8c\u8868\u660e\uff1a\u572890%\u53ec\u56de\u4e0b\uff0c\u5e73\u5747\u51cf\u5c1146% I/O\u64cd\u4f5c\uff0c\u67e5\u8be2\u541e\u5410\u63d0\u53471.73\u500d\uff0c\u67e5\u8be2\u5ef6\u8fdf\u964d\u4f4e42%\uff0c\u4f18\u4e8e\u6700\u5148\u8fdb\u7684\u78c1\u76d8\u56fe\u7d22\u5f15\u7cfb\u7edf\u3002", "conclusion": "GoVector\u901a\u8fc7\u7ed3\u5408\u9759\u6001\u7f13\u5b58\u4e0e\u52a8\u6001\u7f13\u5b58\u5e76\u5bf9\u78c1\u76d8\u8282\u70b9\u91cd\u6392\uff0c\u6709\u6548\u63d0\u9ad8\u4e86\u57fa\u4e8e\u56fe\u7684\u78c1\u76d8\u5411\u91cf\u7d22\u5f15\u7684I/O\u6548\u7387\uff0c\u4ece\u800c\u5728\u9ad8\u53ec\u56de\u4e0b\u663e\u8457\u964d\u4f4eI/O\u91cf\u3001\u63d0\u5347\u541e\u5410\u5e76\u51cf\u5c11\u5ef6\u8fdf\u3002"}}
